from argparse import ArgumentParser
from capability import CapabilityExtractor
from os import PathLike, path
from pathlib import Path
from typing import List
import capa_parser
import json
import networkx as nx

"""
behaviour_graph_gen is a script to get the behaviour graph from a binary
from a remote IDA server.

behaviour_graph_gen requires the following arguments:
- binary/malware to be analyzed
- cfg.dot and metadata.json generated by ida_cfg_gen.py on the binary/malware
"""


def load_metadata(metadata_path: str) -> dict:
    """
    Reads the metadata from a .json file to dictionary in memory
    """
    with open(metadata_path, "r") as f:
        meta = json.loads(f.read())
        return meta


def find_last_instruction(instr: str) -> str:
    """
    Takes in the instruction sets and returns the last instruction (usually we only care about jmp instructions)
    Example:
        in: 'mov     eax, dword_4046C4\\limul    eax, 0EA60h\\lpush    eax\\lcall    ds:Sleep\\ljmp     short loc_4029A1\\l'
        out: 'jmp short loc_4029A1'
    """
    instr_list = instr.split("\\l")
    if len(instr_list) < 2:
        return instr
    return instr_list[-2]  # the last element should be an empty string, due to the extra \\l at the back


def add_prop_to_BB(binary_path: PathLike, metadata_path: PathLike, graph: object):
    """
    Augments additional information to each basic blocks
    The list of additional properties is listed in `PROP` dictonary
    """

    # some comments:
    # - initially, 'label' contains the 'instruction_sets' of the basic block
    #   set_node_attributes will override this value if 'label' is included in PROP, thus it is commented out
    # - start_ea and end_ea will be provided by the metadata dictionary obtained from load_metadata()
    # - we dont initialise each value in PROP with an empty list [] because it will be copied by reference
    # https://networkx.org/documentation/stable/reference/generated/networkx.classes.function.set_node_attributes.html

    PROP = {
        'is_top_node': False,  # -> bool
        'capa_node': False,  # -> bool
        'capa_id': None,  # -> list(str)
        'capa_title': None,  # -> list(str)
        'mbc_id': None,  # -> list(str)
        'mbc_title': None,  # -> list(str)
        'instruction_sets': None,  # -> str
        'location': None,  # -> int or None
        # label -> list(str)
        # start_ea -> int
        # end_ea -> int
    }

    for key, val in PROP.items():
        nx.set_node_attributes(graph, val, key)
    metadata = load_metadata(metadata_path)
    nx.set_node_attributes(graph, metadata)

    for node in graph.nodes(data=True):
        node[1]['is_top_node'] = graph.in_degree[node[0]] == 0
        node[1]['capa_id'] = []
        node[1]['capa_title'] = []
        node[1]['mbc_id'] = []
        node[1]['mbc_title'] = []
        node[1]['instruction_sets'] = node[1]['label']
        node[1]['location'] = []
        node[1]['label'] = []

    capa_json_dict = CapabilityExtractor().getCapJson(binary_path)
    fn2capa = capa_parser.get_fn2capa(capa_json_dict)

    graph_map = [(node[1]['start_ea'], node[0]) for node in graph.nodes(data=True)]
    graph_map.sort()  # list of tuples (start_ea, block_id), sorted using start address as key.
    for addr, capabilities in fn2capa.items():
        capa_addr = int(addr, 16)
        # entry = bisect_left(graph_map, capa_addr, key=lambda x: x[0]) - 1  # finding the basic block where the address reside using binary search
        node = graph.nodes[str(0)]
        for curr_addr, curr_node in graph_map:
            if capa_addr < curr_addr:
                node = graph.nodes[str(int(curr_node)-1)]
                break

        node['capa_node'] = True
        node['location'].append(capa_addr)

        for c in capabilities:
            for capability, properties in c.items():
                node['capa_title'].append(capability)
                node['label'].append(capability)
                if isinstance(properties, str):  # items with no capability id, such as 'contain loop'
                    continue
                node['capa_id'].append(properties.get('id'))
                node['mbc_id'].append(properties.get('id'))
                node['mbc_title'].append("::".join(properties.get('parts')))
        node['fillcolor'] = "red"

    JUMPS = ["jo", "jno", "js", "jns", "je", "jz", "jne", "jnz", "jb", "jnae",
             "jc", "jnb", "jae", "jnc", "jbe", "jna", "ja", "jnbe", "jl",
             "jnge", "jnl", "jle", "jng", "jg", "jnle", "jp", "jpe", "jnp",
             "jpo", "jcxz", "jecxz"]

    for node in graph.nodes(data=True):
        if node[1]['capa_node']:
            continue

        is_cond_node = False
        for instr in JUMPS:
            is_cond_node = is_cond_node or (instr in node[1]['instruction_sets'])

        if is_cond_node:
            jump_instr = find_last_instruction(node[1]['instruction_sets'])
            node[1]['capa_id'].append("cnd")
            node[1]['capa_title'].append(jump_instr)
            node[1]['mbc_id'].append("cnd")
            node[1]['mbc_title'].append(jump_instr)
            node[1]['label'].append(jump_instr)

    # for node in graph.nodes(data=True):
    #     print(node)
    return None


def simplify_subgraph(graph: object, visited: List[bool], node_idx: str):
    """
    simplify_subgraph recursively removes a node from a graph by connecting all incoming edge to all outgoing edges
    suppose node N has incoming edges {in1..inN}
    - in1 -> N,
    - in2 -> N,
    - inN -> N,

    and outgoing edges {out1..outN}:
    - N -> out1
    - N -> out2
    - N -> outN

    after N is removed, we have {in1..inN} x {out1..outN}
    - in1 -> out1
    - in1 -> out2
    - ...
    - inN -> outN
    """
    visited[int(node_idx)] = True

    # post-order
    for neighbor in list(graph.adj[node_idx]):
        if not visited[int(neighbor)]:
            simplify_subgraph(graph, visited, neighbor)

    node = graph.nodes[node_idx]
    removable = ((not node['is_top_node']) or (graph.out_degree[node_idx] == 0)) \
        and (not node['capa_node']) \
        and (len(node['capa_id']) == 0)

    incoming = graph.in_edges(node_idx, data=True)
    outgoing = graph.out_edges(node_idx, data=True)

    if removable:
        # connect the parent nodes with the children nodes
        new_edges = []
        for i in incoming:
            for o in outgoing:
                # edge = (src, dest, properties)
                # here, we are using the properties/data flow information (true,false)
                # of the parent node, since the node can be only removed if it does not end 
                # with a jump instruction (hence, the properties of the outgoing edges will always be empty)
                new_edges.append((i[0], o[1], i[2]))

        # remove the node
        graph.remove_node(node_idx)

    return None


def simplify_graph(graph: object):
    """
    start from nodes without incoming edges, traverse the graph using DFS
    if all outgoing edges connect to normal basic blocks (without capa), then remove node
    removing node -> connect all incoming edges to outgoing edges
    """
    visited = [False for _ in graph.nodes]
    for node in list(graph.nodes(data=True)):
        if node[1]['is_top_node']:
            if graph.out_degree[node[0]] > 0:
                simplify_subgraph(graph, visited, node[0])
            else:  # top node without successors
                graph.remove_node(node[0])
    return None


def gen_behavior_graph(binary_path: PathLike, cfg_path: PathLike, metadata_path: PathLike):
    print("loading cfg...")
    graph = nx.nx_agraph.read_dot(cfg_path)

    print("adding metadata to basic blocks...")
    add_prop_to_BB(binary_path, metadata_path, graph)

    print("simplifying cfg...")
    simplify_graph(graph)
    nx.nx_agraph.write_dot(graph, path.dirname(cfg_path) + '/simplified.dot')
    return graph


def main():
    argparser = ArgumentParser(description='Produce behaviour graph from control flow graph')
    argparser.add_argument('-b', '--binary', required=True, help='binary to be analysed')
    argparser.add_argument('-c', '--cfg', required=True, help='control flow graph, in .DOT format')
    argparser.add_argument('-m', '--metadata', required=True, help='metadata about start and end address of basic block, in .json format')
    args = argparser.parse_args()
    gen_behavior_graph(Path(args.binary), Path(args.cfg), Path(args.metadata))


if __name__ == "__main__":
    main()
