#!/usr/bin/python3

import bisect
import json
import pydot
import sys

import capa_parser

INPUT_DIR = ""
OUTPUT_DIR = ""

def debug_graph(graph, pr_nodes=False, pr_edges=False):
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()

    if pr_nodes:
        for n in nodes:
            print(n.get_name(), type(n.get_name()), n.get_name().encode())
            print(f"name: {n.get_name()}, label: {n.get_label()}, comment: {n.get_comment()}")

    if pr_edges:
        for e in edges:
            print(f"source: {e.get_source()}, dest: {e.get_destination()}, label: {e.get_label()}")

def load_cfg():
    graphs = pydot.graph_from_dot_file(f"{INPUT_DIR}cfg.dot")
    graph = graphs[0]
    # assert(len(graphs) == 1)
    # assert(type(graph) == pydot.Dot) 

    nodes = graph.get_node_list()
    for n in nodes:
        # filter out wrongly parsed nodes i.e. "graph", "edge", "\n"
        idx = n.get_name().strip("\"")
        if not idx.isnumeric():
            graph.del_node(n)
            continue
        else:
            n.set_name(idx)

        prev_label = n.get_label() # bytes or string
        if isinstance(prev_label, bytes):
            prev_label = prev_label.decode("unicode_escape")
        new_label = f"\"block_id: {idx}\l\l" + prev_label[1:]
        n.set_label(new_label)

    out_ezgraph = [ list() for _ in graph.get_node_list() ] # adj list, for easier processing during pruning/simplification
    in_ezgraph = [ list() for _ in graph.get_node_list() ]  # in: incoming edges, out: outgoing edges.
    #print(in_ezgraph)
    for e in graph.get_edge_list():
        src = int(e.get_source().strip("\""))
        dest = int(e.get_destination().strip("\""))
        # print(src, dest)
        if src == dest: # skip self loop
            continue
        out_ezgraph[src].append(dest)
        in_ezgraph[dest].append(src)

    return graph, out_ezgraph, in_ezgraph

# add information about start and end address for each basic block in the 'comment' attribute
def add_address_to_BB(graph):
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()

    with open(f"{INPUT_DIR}metadata.json", "r") as f:
        meta = json.loads(f.read())

        for n in nodes:
            # filter out wrongly parsed nodes i.e. "graph", "edge", "\n"
            idx = n.get_name().strip("\"")
            n.set_comment(meta[idx])
            n.set_shape("box")
    return None

def augment_capa_info(graph):
    graph_map = [ (n.get_comment()['start_ea'], n.get_name()) for n in graph.get_node_list() ]
    graph_map.sort() # list of tuples (start_ea, BB_name), sorted using start address as key. 
    #for n in graph_map:
        #print(type(n[0]), type(n[1]))

    fn2capa = capa_parser.get_fn2capa(f"{INPUT_DIR}capabilities.json")
    for k,v in fn2capa.items():
        capa_addr = int(k, 16)
        entry = bisect.bisect_left(graph_map, capa_addr, key=lambda x: x[0]) - 1 # finding the basic block where the address reside using binary search
        #print(f"capa_addr: {hex(capa_addr)}")
        #print(f"graph idx: {entry}")
        #print(f"start_ea: {hex(graph_map[entry][0])}, node_name: {graph_map[entry][1]} -> {type(graph_map[entry][1])}, {graph.get_node(graph_map[entry][1])}")

        capability = [ key for key,value in v[0].items() ]
        prev_label = graph.get_nodes()[entry].get_label() # bytes or string
        if isinstance(prev_label, bytes):
            prev_label = prev_label.decode("unicode_escape")
        new_label = prev_label[:-1] + "\l\lCAPA: " + capability[0] + "\""
        #new_label = "CAPA: " + capability[0]

        graph.get_nodes()[entry].set_label(new_label)
        graph.get_nodes()[entry].set_style("filled")
        graph.get_nodes()[entry].set_fillcolor("red")
        

    return None

def clean_BB_metadata(graph):
    for n in graph.get_node_list():
        n.set_comment("")
    
"""
remove_dfs recursively removes a node from a graph by connecting all incoming edge to all outgoing edges
    1. in -> node 
    2. node -> out
    output: in -> out

suppose a node has some incoming edges {in1..inN}
    in1 -> node,
    in2 -> node,
    inN -> node

and some outgoing edges {out1..outN}:
    node -> out1
    node -> out2
    node -> outN

the end result will be as follows (cross product):
    in1 -> out1
    in1 -> out2
    ...
    inN -> outN
"""
def remove_dfs(graph, out_ezgraph, in_ezgraph, visited, node_idx):
    #print("remove_dfs start", node_idx)
    visited[node_idx] = True

    # post-order
    for o in out_ezgraph[node_idx]:
        if not visited[o]:
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, o)

    collapseable = "CAPA: " not in graph.get_nodes()[node_idx].get_label()

    incoming = in_ezgraph[node_idx]
    outgoing = out_ezgraph[node_idx]
    if collapseable and len(incoming) > 0 and len(outgoing) > 0:
        for i in incoming:
            graph.del_edge(f"\"{str(i)}\"", f"\"{str(node_idx)}\"")
        for o in outgoing:
            graph.del_edge(f"\"{str(node_idx)}\"", f"\"{str(o)}\"")

        #print(f"deleting {node_idx}")
        curr_node = graph.get_nodes()[node_idx]
        #curr_node.set_comment("DELETE")
        print(curr_node.get_name(), node_idx)
        #print(type(curr_node.get_name()), type(node_idx), curr_node)
        print(graph.del_node(str(node_idx)))
        out_ezgraph[node_idx] = list()
        in_ezgraph[node_idx] = list()

        for i in incoming:
            for o in outgoing:
                new_e = pydot.Edge(f"\"{i}\"", f"\"{o}\"")
                #print("new_e", new_e.get_source(), new_e.get_destination())
                graph.add_edge(new_e)
                #if node_idx in in_ezgraph[o]:
                #    in_ezgraph[o].remove(node_idx)
                #in_ezgraph[o].append(i)
                #if node_idx in out_ezgraph[i]:
                #    out_ezgraph[i].remove(node_idx)
                #out_ezgraph[i].append(o)

    return None

    
"""
 start from nodes without incoming edges, traverse the graph using DFS
 if all outgoing edges connect to normal basic blocks (without capa), then remove node
 removing node -> connect all incoming edges to outgoing edges
"""
def simplify_graph(graph, out_ezgraph, in_ezgraph):
    visited = [ False for _ in out_ezgraph ]
    for idx, nodes in enumerate(in_ezgraph):
        if idx == 0:
            continue
        if (not visited[idx]) and len(nodes) == 0: 
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, idx)
        

def gen_behavior_graph():
    print("loading cfg...")
    graph, out_ezgraph, in_ezgraph = load_cfg()

    print("adding basic block metadata...")
    add_address_to_BB(graph)
    debug_graph(graph,False,False)

    print("adding capa info...")
    augment_capa_info(graph)
    clean_BB_metadata(graph)

    print("DEBUG generating pre-pruned behavior graph...")
    graph.write_svg(f"{OUTPUT_DIR}pre-pruning.svg")
    graph.write_png(f"{OUTPUT_DIR}pre-pruning.png")
    graph.write_dot(f"{OUTPUT_DIR}pre-pruning.dot")

    print("simplifying cfg...")
    simplify_graph(graph, out_ezgraph, in_ezgraph)

    print("generating behavior graph...")
    graph.set_node_defaults(shape="box")
    graph.write_svg(f"{OUTPUT_DIR}post-pruning.svg")
    graph.write_png(f"{OUTPUT_DIR}post-pruning.png")
    graph.write_dot(f"{OUTPUT_DIR}post-pruning.dot")
    return None
        
def main():
    global INPUT_DIR
    INPUT_DIR = sys.argv[1]
    global OUTPUT_DIR
    OUTPUT_DIR= sys.argv[2]
    cfg = gen_behavior_graph()

if __name__ == "__main__":
    main()
