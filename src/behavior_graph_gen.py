#!/usr/bin/python3

import ast
import bisect
import json
import pydot
import sys

import capa_parser

INPUT_DIR = ""
OUTPUT_DIR = ""

def debug_graph(graph, pr_nodes=False, pr_edges=False):
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()

    if pr_nodes:
        for n in nodes:
            print(n.get_name(), type(n.get_name()), n.get_name().encode())
            print(f"name: {n.get_name()}, label: {n.get_label()}, comment: {n.get_comment()}")

    if pr_edges:
        for e in edges:
            print(f"source: {e.get_source()}, dest: {e.get_destination()}, label: {e.get_label()}")
    return None

"""
Loads the control flow graph from DOT format and pre-process the cfg
In addition to the pydot graph object, construct a new graph using adjacency list (in/out edges)
Returns: the pydot graph object, and the adjacency lists
"""
def load_cfg():
    graphs = pydot.graph_from_dot_file(f"{INPUT_DIR}cfg.dot")
    graph = graphs[0]

    """
    - filter out wrongly parsed nodes i.e. "graph", "edge", "\n"
    - rename the nodes from ""x"" to "x"
    - add block id for debugging and standardise the node label to string
    """
    nodes = graph.get_node_list()
    for n in nodes:
        idx = n.get_name().strip("\"")
        if not idx.isnumeric():
            graph.del_node(n)
            continue
        else:
            n.set_name(idx)

        # prev_label = n.get_label() # bytes or string
        # if isinstance(prev_label, bytes):
        #     prev_label = prev_label.decode("unicode_escape")
        # new_label = f"\"block_id: {idx}\l\l" + prev_label[1:]
        # n.set_label(new_label)

    out_ezgraph = [ set() for _ in graph.get_node_list() ] # adj list, for easier processing during pruning/simplification
    in_ezgraph = [ set() for _ in graph.get_node_list() ]  # in: incoming edges, out: outgoing edges.
    for e in graph.get_edge_list():
        src = int(e.get_source().strip("\""))
        dest = int(e.get_destination().strip("\""))
        # print(src, dest)
        if src == dest: # skip self loop
            continue
        out_ezgraph[src].add(dest)
        in_ezgraph[dest].add(src)

    return graph, out_ezgraph, in_ezgraph

"""
Adds information about start and end address for each basic block in the 'comment' attribute
"""
def add_prop_to_BB(graph):
    prop = {
        'is_top_node': False, # -> bool
        'capa_node': False, # -> bool
        'capa_id': None, # -> list(str)
        'capa_title': None, # -> list(str)
        'mbc_id': None, # -> list(str)
        'mbc_title': None, # -> list(str)
        'instruction_sets': None, # -> str
        'label': None, # -> list(str)
        'location': None, # -> int or None
        # start_ea -> int
        # end_ea -> int
    }
    nodes = graph.get_node_list()
    with open(f"{INPUT_DIR}metadata.json", "r") as f:
        meta = json.loads(f.read())
        for n in nodes:
            idx = n.get_name().strip("\"")
            n.set_comment(prop | meta[idx])
            n.set_shape("box")
    return None

def find_last_instruction(instr):
    if not instr:
        return ""
    idx = instr.rfind("\\l")
    if idx == -1:
        return ""
    instr = instr[:idx]
    idx = instr.rfind("\\l")
    if idx == -1:
        return ""
    return instr[idx+2:] # +2 to remove the last '\\l'
    
"""
Adds capability/conditional information generated by capa to the relevant basic blocks.
"""
def add_info_to_prop(graph):
    nodes = graph.get_node_list()
    for n in nodes:
        prop = n.get_comment()
        prop['instruction_sets'] = n.get_label() 
        is_cond_node = False
        JUMPS = ["jo", "jno", "js", "jns", "je", "jz", "jne", "jnz", "jb", "jnae", "jc", "jnb", "jae", "jnc", "jbe", "jna", "ja", "jnbe", "jl", "jnge", "jnl", "jle", "jng", "jg", "jnle", "jp", "jpe", "jnp", "jpo", "jcxz", "jecxz"]
        for instr in JUMPS:
            is_cond_node = is_cond_node or (instr in prop['instruction_sets'])
        if is_cond_node:
            jump_instr = find_last_instruction(prop['instruction_sets'])
            prop['capa_id'] = ["cnd"]
            prop['capa_title'] = [jump_instr]
            prop['mbc_id'] = ["cnd"]
            prop['mbc_title'] = [jump_instr]
            prop['label'] = [jump_instr]
        else:
            prop['capa_id'] = [""]
            prop['capa_title'] = [""]
            prop['mbc_id'] = [""]
            prop['mbc_title'] = [""]
            prop['label'] = [""]
            
        n.set_label("\"" + "\n".join(prop['label']) + "\"")
        n.set_comment(prop)

    graph_map = [ (n.get_comment()['start_ea'], n.get_name()) for n in graph.get_node_list() ]
    graph_map.sort() # list of tuples (start_ea, BB_name), sorted using start address as key. 
    fn2capa = capa_parser.get_fn2capa(f"{INPUT_DIR}capabilities.json")
    for addr,capabilities in fn2capa.items():
        capa_addr = int(addr, 16)
        entry = bisect.bisect_left(graph_map, capa_addr, key=lambda x: x[0]) - 1 # finding the basic block where the address reside using binary search
        node = graph.get_nodes()[entry]
        prop = node.get_comment()

        # print("before: ", node.get_name(), prop)
        prop['capa_node'] = True

        if not prop['location']:
            prop['location'] = []
        prop['location'].append(capa_addr)

        if not prop['instruction_sets']:
            prop['instruction_sets'] = node.get_label() # bytes or string 

        for c in capabilities:
            for capability, properties in c.items():
                if not prop['capa_title']:
                    prop['capa_title'] = []
                prop['capa_title'].append(capability)

                if not prop['label']:
                    prop['label'] = []
                prop['label'].append(capability)

                if isinstance(properties, str): # items with no capability id, such as 'contain loop'
                    continue
                if not prop['capa_id']:
                    prop['capa_id'] = []
                prop['capa_id'].append(properties.get('id'))

                if not prop['mbc_id']:
                    prop['mbc_id'] = []
                prop['mbc_id'].append(properties.get('id'))

                if not prop['mbc_title']:
                    prop['mbc_title'] = []
                prop['mbc_title'].append("::".join(properties.get('parts'))) 

        node.set_label("\"" + "\n".join(prop['label']) + "\"")
        node.set_comment(prop)
        
        node.set_style("filled")
        node.set_fillcolor("red")
        # print("after: ", node.get_name(), prop)
        # print(f"capa addr: {addr}, capabilities: {capabilities}")
    return None

"""
remove_dfs recursively removes a node from a graph by connecting all incoming edge to all outgoing edges
    1. in -> node 
    2. node -> out
    output: in -> out

suppose a node has some incoming edges {in1..inN}
    in1 -> node,
    in2 -> node,
    inN -> node

and some outgoing edges {out1..outN}:
    node -> out1
    node -> out2
    node -> outN

the end result will be as follows (cross product):
    in1 -> out1
    in1 -> out2
    ...
    inN -> outN
"""
def remove_dfs(graph, out_ezgraph, in_ezgraph, visited, node_idx):
    visited[node_idx] = True

    # post-order
    outgoing = out_ezgraph[node_idx].copy()
    for o in outgoing:
        if not visited[o]:
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, o)

    prop = graph.get_nodes()[node_idx].get_comment()
    removable = (not prop['is_top_node']) and (not prop['capa_node']) and (not prop['capa_id'][0] == "cnd")
        
    incoming = in_ezgraph[node_idx]
    outgoing = out_ezgraph[node_idx]
    #if removable and len(incoming) > 0 and len(outgoing) > 0:
    if removable:
        # color=darkgreen,
        # label=true,
        # color=red,
        # label=false,
        # connect the parent nodes with the children nodes
        for i in incoming:
            # preserve the data flow information 
            curr_e = graph.get_edge(f"\"{str(i)}\"", f"\"{str(node_idx)}\"")
            curr_e = curr_e if isinstance(curr_e, list) else [curr_e]
            # print(curr_e, len(curr_e))
            # for e in curr_e:
                # print(int(e.get_source().strip("\"")), "->", int(e.get_destination().strip("\"")))
            for o in outgoing:
                if curr_e[0].get_label(): # todo: check if there's more than 1 in the list
                    new_e = pydot.Edge(f"\"{i}\"", f"\"{o}\"", label=curr_e[0].get_label(), color=curr_e[0].get_color())
                else:
                    new_e = pydot.Edge(f"\"{i}\"", f"\"{o}\"")
                graph.add_edge(new_e)
                in_ezgraph[o].add(i)
                out_ezgraph[i].add(o)

        # remove the edges
        for i in incoming:
            graph.del_edge(f"\"{str(i)}\"", f"\"{str(node_idx)}\"")
            #out_ezgraph[i].remove(node_idx)
            out_ezgraph[i].discard(node_idx)

        for o in outgoing:
            graph.del_edge(f"\"{str(node_idx)}\"", f"\"{str(o)}\"")
            #in_ezgraph[o].remove(node_idx)
            in_ezgraph[o].discard(node_idx)

        # remove the node
        curr_node = graph.get_nodes()[node_idx]
        curr_node.set_comment("DELETE")
        # ret = graph.del_node(curr_node)
        # print(ret)

        in_ezgraph[node_idx].clear()
        out_ezgraph[node_idx].clear()

    return None

    
"""
start from nodes without incoming edges, traverse the graph using DFS
if all outgoing edges connect to normal basic blocks (without capa), then remove node
removing node -> connect all incoming edges to outgoing edges
"""
def simplify_graph(graph, out_ezgraph, in_ezgraph):
    visited = [ False for _ in out_ezgraph ]
    node_list = graph.get_node_list()
    for idx, nodes in enumerate(in_ezgraph):
        if (not visited[idx]) and len(nodes) == 0: 
            prop = node_list[idx].get_comment()
            prop['is_top_node'] = True
            node_list[idx].set_comment(prop)
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, idx)
    return None

"""
construct a new graph since deleting nodes does not really work
"""
def construct_new_graph(graph, out_ezgraph, in_ezgraph):
    new_graph = pydot.Dot(graph_name='behavior-graph', obj_dict=None, graph_type='digraph', strict=False, suppress_disconnected=False, simplify=True)
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()
    added_nodes = set()
    added_edges = set()

    for n in nodes:
        idx = int(n.get_name().strip("\""))
        if ("DELETE" in n.get_comment()) or (len(in_ezgraph[idx]) == 0 and len(out_ezgraph[idx]) == 0):
            continue
        added_nodes.add(idx)
        new_graph.add_node(n)

    for e in edges:
        src = int(e.get_source().strip("\""))
        dst = int(e.get_destination().strip("\""))
        edge_key = f"{src}-{dst}"
        if (edge_key in added_edges) or (src not in added_nodes) or (dst not in added_nodes):
            continue
        new_graph.add_edge(e)
        added_edges.add(edge_key)

    return new_graph
    
"""
The comment attribute of the graph is of type dictionary
pydot can't write this to a .dot file
convert this to string before writing
"""
def convert_prop_dict2str(graph):
    nodes = graph.get_node_list()
    for n in nodes:
        # print(n.get_name(), n.get_label())
        c = n.get_comment()
        # print(c)
        n.set_comment(str(c))
        
"""
Parse the comment attribute read from .dot file 
and convert it to dictionary
"""
def convert_prop_str2dict(graph):
    nodes = graph.get_node_list()
    for n in nodes:
        # print(n.get_name(), n.get_label())
        c = n.get_comment()
        # print(c)
        n.set_comment(ast.literal_eval(c.strip("\"")))

def gen_behavior_graph():
    print("loading cfg...")
    graph, out_ezgraph, in_ezgraph = load_cfg()

    print("adding metadata to basic blocks...")
    add_prop_to_BB(graph)

    print("adding capa/jmp info to the metadata...")
    add_info_to_prop(graph)

    convert_prop_dict2str(graph) 
    print("generating pre-simplified behavior graph...")
    graph.write_svg(f"{INPUT_DIR}annotated-cfg.svg")
    # graph.write_png(f"{INPUT_DIR}annotated-cfg.png")
    graph.write_dot(f"{INPUT_DIR}annotated-cfg.dot")

    convert_prop_str2dict(graph)
    print("simplifying cfg...")
    simplify_graph(graph, out_ezgraph, in_ezgraph)
    graph = construct_new_graph(graph, out_ezgraph, in_ezgraph)

    convert_prop_dict2str(graph) 
    print("generating behavior graph...")
    graph.set_node_defaults(shape="box")
    graph.write_svg(f"{OUTPUT_DIR}behavior-graph.svg")
    # graph.write_png(f"{OUTPUT_DIR}behavior-graph.png")
    graph.write_dot(f"{OUTPUT_DIR}behavior-graph.dot")
    return None
        
def main():
    global INPUT_DIR
    INPUT_DIR = sys.argv[1]
    global OUTPUT_DIR
    OUTPUT_DIR= sys.argv[2]
    cfg = gen_behavior_graph()

if __name__ == "__main__":
    main()
