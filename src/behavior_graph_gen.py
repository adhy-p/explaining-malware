#!/usr/bin/python3

import bisect
import json
import pydot
import sys

import capa_parser

INPUT_DIR = ""
OUTPUT_DIR = ""

def debug_graph(graph, pr_nodes=False, pr_edges=False):
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()

    if pr_nodes:
        for n in nodes:
            print(n.get_name(), type(n.get_name()), n.get_name().encode())
            print(f"name: {n.get_name()}, label: {n.get_label()}, comment: {n.get_comment()}")

    if pr_edges:
        for e in edges:
            print(f"source: {e.get_source()}, dest: {e.get_destination()}, label: {e.get_label()}")
    return None

"""
Loads the control flow graph from DOT format and pre-process the cfg
In addition to the pydot graph object, construct a new graph using adjacency list (in/out edges)
Returns: the pydot graph object, and the adjacency lists
"""
def load_cfg():
    graphs = pydot.graph_from_dot_file(f"{INPUT_DIR}cfg.dot")
    graph = graphs[0]

    """
    - filter out wrongly parsed nodes i.e. "graph", "edge", "\n"
    - rename the nodes from ""x"" to "x"
    - add block id for debugging and standardise the node label to string
    """
    nodes = graph.get_node_list()
    for n in nodes:
        idx = n.get_name().strip("\"")
        if not idx.isnumeric():
            graph.del_node(n)
            continue
        else:
            n.set_name(idx)

        # prev_label = n.get_label() # bytes or string
        # if isinstance(prev_label, bytes):
        #     prev_label = prev_label.decode("unicode_escape")
        # new_label = f"\"block_id: {idx}\l\l" + prev_label[1:]
        # n.set_label(new_label)

    out_ezgraph = [ set() for _ in graph.get_node_list() ] # adj list, for easier processing during pruning/simplification
    in_ezgraph = [ set() for _ in graph.get_node_list() ]  # in: incoming edges, out: outgoing edges.
    for e in graph.get_edge_list():
        src = int(e.get_source().strip("\""))
        dest = int(e.get_destination().strip("\""))
        # print(src, dest)
        if src == dest: # skip self loop
            continue
        out_ezgraph[src].add(dest)
        in_ezgraph[dest].add(src)

    return graph, out_ezgraph, in_ezgraph

"""
Adds information about start and end address for each basic block in the 'comment' attribute
"""
def add_address_to_BB(graph):
    nodes = graph.get_node_list()
    with open(f"{INPUT_DIR}metadata.json", "r") as f:
        meta = json.loads(f.read())
        for n in nodes:
            idx = n.get_name().strip("\"")
            n.set_comment(meta[idx])
            n.set_shape("box")
    return None

"""
Adds capability information generated by capa to the relevant basic blocks.
"""
def augment_capa_info(graph):
    graph_map = [ (n.get_comment()['start_ea'], n.get_name()) for n in graph.get_node_list() ]
    graph_map.sort() # list of tuples (start_ea, BB_name), sorted using start address as key. 

    fn2capa = capa_parser.get_fn2capa(f"{INPUT_DIR}capabilities.json")
    for k,v in fn2capa.items():
        capa_addr = int(k, 16)
        entry = bisect.bisect_left(graph_map, capa_addr, key=lambda x: x[0]) - 1 # finding the basic block where the address reside using binary search

        # print(f"capa_addr: {hex(capa_addr)}")
        # print(f"graph idx: {entry}")
        # print(f"start_ea: {hex(graph_map[entry][0])}, node_name: {graph_map[entry][1]} -> {type(graph_map[entry][1])}, {graph.get_node(graph_map[entry][1])}")

        capability = [ key for key,value in v[0].items() ]
        #prev_label = graph.get_nodes()[entry].get_label() # bytes or string
        #new_label = prev_label[:-1] + "\l\lCAPA: " + capability[0] + "\""
        new_label =  "\"" + "CAPA: " + capability[0] + "\""

        graph.get_nodes()[entry].set_label(new_label)
        graph.get_nodes()[entry].set_style("filled")
        graph.get_nodes()[entry].set_fillcolor("red")
    return None

"""
Removes information about start and end address for each basic block in the 'comment' attribute
"""
def clean_BB_metadata(graph):
    for n in graph.get_node_list():
        n.set_comment("")
    return None
    
"""
remove_dfs recursively removes a node from a graph by connecting all incoming edge to all outgoing edges
    1. in -> node 
    2. node -> out
    output: in -> out

suppose a node has some incoming edges {in1..inN}
    in1 -> node,
    in2 -> node,
    inN -> node

and some outgoing edges {out1..outN}:
    node -> out1
    node -> out2
    node -> outN

the end result will be as follows (cross product):
    in1 -> out1
    in1 -> out2
    ...
    inN -> outN
"""
def remove_dfs(graph, out_ezgraph, in_ezgraph, visited, node_idx):
    visited[node_idx] = True

    # post-order
    outgoing = out_ezgraph[node_idx].copy()
    for o in outgoing:
        if not visited[o]:
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, o)

    removable = "CAPA: " not in graph.get_nodes()[node_idx].get_label()
    incoming = in_ezgraph[node_idx]
    outgoing = out_ezgraph[node_idx]
    #if removable and len(incoming) > 0 and len(outgoing) > 0:
    if removable:
        # remove the edges
        for i in incoming:
            graph.del_edge(f"\"{str(i)}\"", f"\"{str(node_idx)}\"")
            #out_ezgraph[i].remove(node_idx)
            out_ezgraph[i].discard(node_idx)

        for o in outgoing:
            graph.del_edge(f"\"{str(node_idx)}\"", f"\"{str(o)}\"")
            #in_ezgraph[o].remove(node_idx)
            in_ezgraph[o].discard(node_idx)

        # remove the node
        curr_node = graph.get_nodes()[node_idx]
        curr_node.set_comment("DELETE")
        # ret = graph.del_node(curr_node)
        # print(ret)

        # connect the parent nodes with the children nodes
        for i in incoming:
            for o in outgoing:
                new_e = pydot.Edge(f"\"{i}\"", f"\"{o}\"")
                graph.add_edge(new_e)
                in_ezgraph[o].add(i)
                out_ezgraph[i].add(o)

        in_ezgraph[node_idx].clear()
        out_ezgraph[node_idx].clear()

    return None

    
"""
start from nodes without incoming edges, traverse the graph using DFS
if all outgoing edges connect to normal basic blocks (without capa), then remove node
removing node -> connect all incoming edges to outgoing edges
"""
def simplify_graph(graph, out_ezgraph, in_ezgraph):
    visited = [ False for _ in out_ezgraph ]
    for idx, nodes in enumerate(in_ezgraph):
        if idx == 0:
            continue
        if (not visited[idx]) and len(nodes) == 0: 
            remove_dfs(graph, out_ezgraph, in_ezgraph, visited, idx)
    return None

"""
construct a new graph since deleting nodes does not really work
"""
def construct_new_graph(graph, out_ezgraph, in_ezgraph):
    new_graph = pydot.Dot(graph_name='behavior-graph', obj_dict=None, graph_type='digraph', strict=False, suppress_disconnected=False, simplify=True)
    nodes = graph.get_node_list()
    edges = graph.get_edge_list()
    added_nodes = set()
    added_edges = set()

    for n in nodes:
        idx = int(n.get_name().strip("\""))
        if ("DELETE" in n.get_comment()) or (len(in_ezgraph[idx]) == 0 and len(out_ezgraph[idx]) == 0):
            continue
        added_nodes.add(idx)
        new_graph.add_node(n)

    for e in edges:
        src = int(e.get_source().strip("\""))
        dst = int(e.get_destination().strip("\""))
        edge_key = f"{src}-{dst}"
        if (edge_key in added_edges) or (src not in added_nodes) or (dst not in added_nodes):
            continue
        new_graph.add_edge(e)
        added_edges.add(edge_key)

    return new_graph
    
        
def gen_behavior_graph():
    print("loading cfg...")
    graph, out_ezgraph, in_ezgraph = load_cfg()

    print("adding basic block metadata...")
    add_address_to_BB(graph)
    debug_graph(graph,False,False)

    print("adding capa info...")
    augment_capa_info(graph)
    clean_BB_metadata(graph)

    print("generating pre-simplified behavior graph...")
    graph.write_svg(f"{INPUT_DIR}annotated-cfg.svg")
    # graph.write_png(f"{INPUT_DIR}annotated-cfg.png")
    # graph.write_dot(f"{INPUT_DIR}annotated-cfg.dot")

    print("simplifying cfg...")
    simplify_graph(graph, out_ezgraph, in_ezgraph)
    graph = construct_new_graph(graph, out_ezgraph, in_ezgraph)

    print("generating behavior graph...")
    graph.set_node_defaults(shape="box")
    graph.write_svg(f"{OUTPUT_DIR}behavior-graph.svg")
    # graph.write_png(f"{OUTPUT_DIR}behavior-graph.png")
    # graph.write_dot(f"{OUTPUT_DIR}behavior-graph.dot")
    return None
        
def main():
    global INPUT_DIR
    INPUT_DIR = sys.argv[1]
    global OUTPUT_DIR
    OUTPUT_DIR= sys.argv[2]
    cfg = gen_behavior_graph()

if __name__ == "__main__":
    main()
