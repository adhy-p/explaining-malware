from argparse import ArgumentParser
import subprocess
import os
import logging
import string
import random
from pathlib import Path
from paramiko import SSHClient
from paramiko import SSHException
from paramiko import BadHostKeyException, AuthenticationException
from paramiko import AutoAddPolicy

from socket import error as SocketError

log =  logging.getLogger(__name__)


class RemoteIDA():
  """RemoteIDA connects to a remote server via SSH. The remote server is
  assumed to have IDApro installed on it.

  """

  def __init__(self, username, host, remote_dir=None, ida_path=None,
               result_files=None, *args, **kwargs):
    """Initializer

      :param username: SSH username for remote IDApro server
      :type username: string
      :param host: server address
      :type host: string
      :param remote_dir: remote directory where results will be stored
      :type remote_dir: Path
      :param ida_path: path to IDApro executable
      :type ida_path: Path
      :returns: RemoteIDA object

    """

    self.username = username
    self.host = host
    self.result_files = result_files
    self.check_ssh()
    self.remote_dir = remote_dir
    self.check_remdir()
    self.ida_path = ida_path
    self.check_idapath()

  # result_files
  @property
  def result_files(self):
    return self._result_files

  @result_files.setter
  def result_files(self, result_files):
    default_result_files = ['cfg.dot', 'metadata.json']
    if not result_files:
      result_files = default_result_files
    elif isinstance(result_files, str):
      result_files = [result_files]
    else:
      try:
        result_files = list(result_files)
      except Exception as e:
        raise ValueError('{} not a collection of file names to fetch.\n{}'
                  .format(result_files, e))
    self._result_files = result_files

  @result_files.deleter
  def result_files(self):
    del self._result_files

  # username
  @property
  def username(self):
    return self._username

  @username.setter
  def username(self, username):
    if username:
      self._username = username
    else:
      raise ValueError('Username cannot be empty or None')

  @username.deleter
  def username(self):
    del self._username

  # host
  @property
  def host(self):
    return self._host

  @host.setter
  def host(self, host):
    if host:
      self._host = host
    else:
      raise ValueError('IDApro Host/Server address cannot be empty or None')

  @host.deleter
  def host(self):
    del self._host

  # remote_dir
  @property
  def remote_dir(self):
    return self._remote_dir

  @remote_dir.setter
  def remote_dir(self, remote_dir):
    if not remote_dir:
      default_dir = Path('/tmp/cfg_generator/')
      log.warning('No remote directory indicated for Remote IDApro server')
      log.info('Using default directory {}'.format(default_dir))
      self._remote_dir = default_dir
    else:
      if not isinstance(remote_dir, Path):
        try:
          remote_dir = Path(remote_dir)
        except Exception as e:
          raise ValueError('Invalid remote directory for Remote IDApro')
      if remote_dir.is_absolute():
        self._remote_dir = remote_dir
      else:
        raise ValueError('The directory path on remote IDA must be absolute.')

  @remote_dir.deleter
  def remote_dir(self):
    del self._remote_dir

  # ida_path
  @property
  def ida_path(self):
    return self._ida_path

  @ida_path.setter
  def ida_path(self, ida_path):
    if not ida_path:
      default_ida_path = Path('/opt/idapro/ida64')
      log.warning('No execution path indicated for remote IDApro on server')
      log.info('Using default IDApro path {}'.format(default_ida_path))
      self._ida_path = default_ida_path
    else:
      if isinstance(ida_path, Path):
        self._ida_path = ida_path
      else:
        try:
          self._ida_path = Path(ida_path)
        except Exception as e:
          raise ValueError('Invalid IDApro path on remote server')

  @ida_path.deleter
  def ida_path(self):
    del self._ida_path


  def check_ssh(self):
    """Checks if the remote server is accessible through SSH with the given
    username and host address

    :returns: True, if the server is accessible

    """
    ssh = SSHClient()
    try:
      ssh.set_missing_host_key_policy(AutoAddPolicy())
      ssh.connect(self.host, username=self.username)
      return True
    except (BadHostKeyException, AuthenticationException, 
            SSHException, SocketError) as e:
      log.fatal('Connection check to Remote IDApro server failed:\n{}'
                .format(e))
      raise SystemError('Could not connect to the SSH server')

  def check_idapath(self):
    """Checks if the indicated path for IDApro executable exists on the
    remote server

    """

    idapath_valid = self.run_command('test -e {}'.format(self.ida_path))
    if idapath_valid.returncode != 0:
      raise FileNotFoundError('Could not locate IDApro executable at {}'
                              .format(self.ida_path))

  def check_remdir(self):
    """Checks if the remote directory on IDApro server already exists.
    If it already exists, backs it up in form of 
      <directory_name>_<unique_str>.bak
    and then creates the requested directory.

    """

    remdir_exists = self.run_command(f"test -e {self.remote_dir}")
    if remdir_exists.returncode == 0:
      # print(f"Remote directory {self.remote_dir} exists. Continue? (y/N)")
      # if (input().lower() != 'y'):
      #   raise SystemExit('Terminated by user.')'
      log.warning('The remote directory {} already exists.'
                  .format(self.remote_dir))
      chars = string.ascii_letters + string.digits
      bak_uid = ''.join(random.choice(chars) for _ in range(4))
      remdir_bak = Path(str(self.remote_dir) + f'_{bak_uid}' + '.bak')
      log.info('Moving existing {} to {}'
               .format(self.remote_dir, remdir_bak))
      mv_remdir_rc = self.run_command('mv {} {}'
                                      .format(self.remote_dir, remdir_bak))
      if mv_remdir_rc.returncode != 0:
        raise SystemError('Remote directory backup failed. Quitting.')

    mkdir_rc = self.run_command(f"mkdir -p {self.remote_dir}")
    if not mkdir_rc.returncode == 0:
      if mkdir_rc.returncode == 255:
        log.fatal('Permission or access issues for {}'
                  .format(self.remote_dir))
      raise OSError(int(mkdir_rc.returncode),
                    'Could not create directory on remote ida.')
    else:
      log.info('Directory {} created on remote IDApro server.'
               .format(self.remote_dir))

  def run_command(self, command):
    """Runs a command using SSH on the remote IDApro server

      :param command: Command to run
      :type command: string
      :returns: result of subprocess

    """

    log.debug(f"run command: ssh -X {self.username}@{self.host} '{command}'")
    return subprocess.run(f"ssh -X {self.username}@{self.host} '{command}'",
                          shell=True, capture_output=True, text=True)

  def copy_to_remote(self, file_path):
    """Copies files to the remote IDApro server

      :param file_path: path to the local file to copy
      :type file_path: Path
      :returns: result of the subprocess

    """

    if not file_path:
      raise ValueError('Invalid file path')
    if not isinstance(file_path, Path):
      try:
        file_path = Path(file_path).resolve(strict=True)
      except Exception as e:
        raise ValueError('Invalid file path {}'.format(file_path))
    rem_dst = f"{self.username}@{self.host}:{self.remote_dir}"
    log.debug(f"run command: scp -r {file_path} {rem_dst}")
    scp_res = subprocess.run(f"scp -r {file_path} {rem_dst}",
                             shell=True, capture_output=True, text=True)
    return scp_res

  def fetch_results(self, dest_path=None):
    """Fetch the files listed in the result_files attribute and store at 
    dest_path

    :param dest_path: destination path to copy/fetch files into
    :type dest_path: Path

    """

    if not dest_path:
      dest_path = self.output_dir
    else:
      try:
        dest_path = Path(dest_path)
      except Exception as e:
        raise ValueError('Invalid destination path for fetch_results\n{}'
                         .format(e))
    dest_path.mkdir(parents=True, exist_ok=True)
    result_file_names = self.result_files
    for res_file in result_file_names:
      fetch_path = Path(self.remote_dir, res_file)
      fetch_res = self.fetch_from_remote(fetch_path, dest_path)
      if fetch_res.returncode != 0:
        log.error('Could not fetch {} from remote IDA server'
                  .format(res_file))
    log.info('Fetched filed stored at {}'.format(dest_path))

  def del_remote_dir(self):
    """Deletes the remote directory

    """

    del_dir_res = self.run_command('rm -rf {}'.format(self.remote_dir))
    if del_dir_res.returncode != 0:
      log.error('Unable to delete the directory {} on IDA server'
                .format(self.remote_dir))

  def fetch_from_remote(self, file_path, output_dir):
    """Fetches files from remote IDApro server, usually the results of
    analysis
      :param file_path: path to the remote file to fetch
      :type file_path: Path
      :param output_dir: path to the local destination directory
      :type output_dir: Path

    """

    if not file_path:
      raise ValueError('Invalid file path')
    if file_path.is_absolute():
      try:
        file_path = Path(file_path)
      except Exception as e:
        raise ValueError('Invalid file path {}'.format(file_path))
    else:
      try:
        file_path = Path(self.remote_dir, file_path)
      except Exception as e:
        raise ValueError('Invalid file path {}'.format(file_path))

    if not output_dir:
      raise ValueError('Invalid file path')
    if not isinstance(output_dir, Path):
      try:
        output_dir = Path(output_dir).resolve(strict=True)
      except Exception as e:
        raise ValueError('Invalid output path {}'.format(output_dir))
    rem_src = f"{self.username}@{self.host}:{file_path}"
    log.debug(f"run command: scp -r {rem_src} {output_dir}")
    return subprocess.run(f"scp -r {rem_src} {output_dir}",
                          shell=True, capture_output=True, text=True)


class CFGExtractor():
  """CFGExtractor class sends an input binary and a script to a remote
  IDApro server. The IDApro server runs the given script on the binary
  and stores the output on the working directory. The script that this
  class is designed to send instructs the IDApro program to extract a
  CFG of the input binary that is sent along the script in .DOT format.

  """

  def __init__(self, remote_ida: RemoteIDA, output_dir=None):
    """Initializes CFGExtractor object

    :param remote_ida: remote IDApro server
    :type remote_ida: 
    :returns: None, creates the output directory will contains:
              - cfg.dot file, the control flow graph of the binary
              - metadata.json file, information about the start and
                end address of each basic block
    """

    self.output_dir = output_dir
    self.remote_ida = remote_ida

  # remote_ida
  @property
  def remote_ida(self):
    return self._remote_ida

  @remote_ida.setter
  def remote_ida(self, remote_ida):
    if not isinstance(remote_ida, RemoteIDA):
      raise ValueError('Initializer argument for remote ida not of type {}'
                       .format(RemoteIDA.__name__))
    if not (remote_ida.username and remote_ida.host):
      raise ValueError('RemoteIDA object has not been initialized properly.')
    self._remote_ida = remote_ida

  @remote_ida.deleter
  def remote_ida(self):
    del self._remote_ida

  # output_dir
  @property
  def output_dir(self):
    return self._output_dir

  @output_dir.setter
  def output_dir(self, output_dir):
    if not output_dir:
      default_output_dir = Path('.').resolve(strict=True)
      log.warning('No output directory indicated. Using pwd {}'
                  .format(default_output_dir))
      self._output_dir = default_output_dir
    else:
      try:
        self._output_dir = Path(output_dir)
      except Exception as e:
        raise ValueError('Invalid output path {}'.format(output_dir))

  @output_dir.deleter
  def output_dir(self):
    del self._output_dir

  def extract(self, malware_path, ida_script_path):
    """Copies a given malware/binary and a CFG extraction script (for
    IDApro) to the remote IDApro server. Runs the CFG extraction script
    on the malware on the remote server, fetches the results and cleans
    up after itself.

    :param malware_path: path to the malware
    :type malware_path: Path
    :param ida_script_path: path to the CFG extraction script for IDApro
    :type ida_script_path: Path
    :returns: Path to the results

    """

    rem_dir = self.remote_ida.remote_dir
    # check paths
    if not isinstance(ida_script_path, Path):
      try:
        ida_script_path = Path(ida_script_path).resolve(strict=True)
      except Exception as e:
        raise ValueError('Invalid script path {}'.format(ida_script_path))
    if not isinstance(malware_path, Path):
      try:
        malware_path = Path(malware_path).resolve(strict=True)
      except Exception as e:
        raise ValueError('Invalid script path {}'.format(ida_script_path))
    # copy the cfg extraction script for ida to the remote server
    script_copy_res = self.remote_ida.copy_to_remote(f"{ida_script_path}")
    if script_copy_res.returncode != 0:
      if script_copy_res.returncode == 255:
        log.fatal('Permission or access issues for {} or {}'
                  .format(ida_script_path, self.remote_dir))
      raise OSError(script_copy_res.returncode,
                    'Could not copy {} to {} on remote ida'
                    .format(ida_script_path, self.remote_dir))
    else:
      log.info('Copied {} to {} on remote IDApro server.'
               .format(ida_script_path, rem_dir))
      rem_script_path = Path(rem_dir, ida_script_path.name)
    # copy the malware to be analyzed to remote ida server
    malware_copy_res = self.remote_ida.copy_to_remote(f"{malware_path}")
    if malware_copy_res.returncode != 0:
      if malware_copy_res.returncode == 255:
        log.fatal('Permission or access issues for {} or {}'
                  .format(malware_path, self.remote_dir))
      raise OSError(malware_copy_res.returncode,
                    'Could not copy {} to {} on remote ida'
                    .format(malware_path, self.remote_dir))
    else:
      log.info('Copied {} to {} on remote IDApro server.'
               .format(malware_path, rem_dir))
      rem_malware_path = Path(rem_dir, malware_path.name)
    cfg_ext_cmd = str('{} -A -S\"{} {}\" {}'
                      .format(self.remote_ida.ida_path,
                              rem_script_path, rem_dir, rem_malware_path))
    cfg_ext_res = self.remote_ida.run_command(cfg_ext_cmd)
    if cfg_ext_res.returncode == 0:
      log.info('[Remote_IDA] CFG extracted for {}. fetching..'
               .format(malware_path.name))
    else:
      log.critical('[Remote_IDA] CFG extraction failed for {}\n{}'
                   .format(malware_path.name, cfg_ext_res))
      raise SystemError('CFG extraction failed. Debug at remote IDA.')
    results_dir = Path(self.output_dir, malware_path.name)
    self.remote_ida.fetch_results(results_dir)
    self.remote_ida.del_remote_dir()
    log.info('Extraction of the CFG completed for {}'
             .format(malware_path.name))
    return results_dir
