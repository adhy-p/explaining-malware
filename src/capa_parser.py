#!/usr/bin/python3

from capability import CapabilityExtractor
from pathlib import Path
from typing import Dict, Tuple, List, Set
import argparse as ap
import logging


def get_capability_locations(data: dict) -> Set[str]:
    """
    For each capability, get the list of addresses
    """
    locations = set()
    if data['locations']:
        locations_type = data['locations'][0].get('type')
        entry = data['locations'][0].get('value')
        if locations_type == 'absolute' and entry:
            locations.add(hex(int(entry)))

    if data['children']:
        for d in data['children']:
            locations.update(get_capability_locations(d))
    return locations


def get_function_capabilities(cap_json: dict) -> Dict[str, Tuple[List[Dict[str, str]], Set[str]]]:
    """
    Get a map of capability to a tuple
    where the first element of the tuple contains a dictionary about the MBC
    and the second element of the tuple contains the address of that capability

    Example:
    {
        'create thread':
            ([{
                'parts': ['Process', 'Create Thread'],
                'objective': 'Process',
                'behavior': 'Create Thread',
                'method': '',
                'id': 'C0038'
            }],
            {'0x401739'})
    }
    """

    """
    cap_json is a nested dictionary
    unpacking cap_json layer by layer until we get our desired data:
    cap_json = {'meta': ..., 'rules': ...}
    cap_json['rules'] = {'capability': ...}
    cap_json['rules']['CAPABILITY'] = {'meta': ..., 'source': ..., 'matches': ...}
    cap_json['rules']['CAPABILITY']['matches'] = [[ {'type': ...}, {'success': ..., 'node': ..., ...}]]
    cap_json['rules']['CAPABILITY']['matches'][0] = [ {'type': ...}, {'success': ..., 'node': ..., ...}]
    cap_json['rules']['CAPABILITY']['matches'][0][-1] = {'success': ..., 'node': ..., ....}
    cap_json['rules']['CAPABILITY']['matches'][0][-1]['locations'] = [ {'locations': ..., 'children': ..., ...} ]
    """
    func_capabilities = dict()
    for capability_name, capability_data in cap_json['rules'].items():
        mbc = capability_data["meta"]["mbc"] if capability_data["meta"]["mbc"]\
                else capability_data["meta"]["attack"]
        func_capabilities[capability_name] = (mbc, get_capability_locations(capability_data['matches'][0][-1]))
    return func_capabilities


def reverse_map(m: Dict[str, Tuple[List[Dict[str, str]], Set[str]]]) -> Dict[str, List[Dict[str, dict]]]:
    """
    Reverse the map from get_function_capabilities
    using the address as the key

    Example:
    {
        0x402799:
        [{'download URL':
            {
                'parts': ['Communication', 'HTTP Communication', 'Download URL'],
                'objective': 'Communication',
                'behavior': 'HTTP Communication',
                'method': 'Download URL',
                'id': 'C0002.006'
            }
        }]
    }
    """
    rev_m = dict()
    for cap_name, cap_data in m.items():
        for addr in cap_data[1]:
            if addr in rev_m:
                rev_m[addr].append({cap_name: cap_data[0][0] if cap_data[0] else ""})  # the mbc might be empty
            else:
                rev_m[addr] = [{cap_name: cap_data[0][0] if cap_data[0] else ""}]
    return rev_m


def get_fn2capa(cap_json: dict) -> Dict[str, List[Dict[str, dict]]]:
    """
    Wrapper to call reverse_map on get_function_capabilities
    """
    return reverse_map(get_function_capabilities(cap_json))


def get_mbc_list(cap_json: dict) -> Set[str]:
    if not cap_json:
        return set()
    """
    Returns a dictionary containing the list of MBCs and ATT&CK ids
    """
    mbcs = set()
    # attacks = set()
    for key, capability_data in cap_json['rules'].items():
        mbc = capability_data["meta"]["mbc"]
        attack = capability_data["meta"]["attack"]
        if mbc:
            mbcs.add(mbc[0]["id"])
        if attack:
            # attacks.add(attack[0]["id"])
            mbcs.add(attack[0]["id"])
        # logging.info("\nitem: ", key)
        # logging.info("\tMBC: ", mbc)
        # logging.info("\tATT&CK: ", attack)

    # logging.info("MBCs: ", mbcs)
    # logging.info("ATT&CKs: ", attacks)
    # return {"MBCS": list(mbcs), "ATTACKS": list(attacks)}
    return mbcs


def load_json(path):
    binPath = Path(path)
    capjson = None
    try:
        capjson = CapabilityExtractor().getCapJson(binPath)  # dict
    except Exception:
        logging.error("capability extraction error for binary {path}")
    return capjson


def main():
    argparser = ap.ArgumentParser(description='''Capability Extractor''')
    argparser.add_argument('BIN', help='Binary file path')
    args = argparser.parse_args()

    cap_json = load_json(args.BIN)
    capa2fn = get_function_capabilities(cap_json)
    fn2capa = reverse_map(capa2fn)
    mbc_list = get_mbc_list(cap_json)

    for k, v in capa2fn.items():
        logging.info(k, v)

    for k, v in fn2capa.items():
        logging.info(k, v)

    for k, v in mbc_list.items():
        logging.info(k, v)


if __name__ == '__main__':
    main()
