#!/usr/bin/python3

from capability import CapabilityExtractor
from pathlib import Path
from typing import Dict, Tuple, List, Set
import argparse as ap


def get_capability_locations(data: dict) -> Set[str]:
    """
    For each capability, get the list of addresses
    """
    locations = set()
    if data['locations']:
        entry = data['locations'][0].get('value')
        if entry:
            locations.add(hex(int(entry)))

    if data['children']:
        for i in data['children']:
            locations.update(get_capability_locations(i))
    return locations


def get_function_capabilities(cap_json: dict) -> Dict[str, Tuple[List[Dict[str, str]], Set[str]]]:
    """
    Get a map of capability to a tuple
    where the first element of the tuple contains a dictionary about the MBC
    and the second element of the tuple contains the address of that capability
    Example:
    {
        'create thread':
            ([{
                'parts': ['Process', 'Create Thread'],
                'objective': 'Process',
                'behavior': 'Create Thread',
                'method': '',
                'id': 'C0038'
            }],
            {'0x401739'})
    }
    """

    """
    cap_json is a nested dictionary
    unpacking cap_json layer by layer until we get our desired data:
    cap_json = {'meta': ..., 'rules': ...}
    cap_json['rules'] = {'capability': ...}
    cap_json['rules']['CAPABILITY'] = {'meta': ..., 'source': ..., 'matches': ...}
    cap_json['rules']['CAPABILITY']['matches'] = [[ {'type': ...}, {'success': ..., 'node': ..., ...}]]
    cap_json['rules']['CAPABILITY']['matches'][0] = [ {'type': ...}, {'success': ..., 'node': ..., ...}]
    cap_json['rules']['CAPABILITY']['matches'][0][-1] = {'success': ..., 'node': ..., ....}
    cap_json['rules']['CAPABILITY']['matches'][0][-1]['locations'] = [ {'locations': ..., 'children': ..., ...} ]
    """
    func_capabilities = dict()
    for key, capability_data in cap_json['rules'].items():
        mbc = capability_data["meta"]["mbc"] if capability_data["meta"]["mbc"] else capability_data["meta"]["attack"]
        func_capabilities[key] = (mbc, get_capability_locations(capability_data['matches'][0][-1]))
    return func_capabilities


def reverse_map(m: Dict[str, Tuple[List[Dict[str, str]], Set[str]]]) -> Dict[str, List[Dict[str, dict]]]:
    """
    Reverse the map from get_function_capabilities
    using the address as the key
    Example:
    {
        0x402799:
        [{'download URL':
            {
                'parts': ['Communication', 'HTTP Communication', 'Download URL'],
                'objective': 'Communication',
                'behavior': 'HTTP Communication',
                'method': 'Download URL',
                'id': 'C0002.006'
            }
        }]
    }
    """
    rev_m = dict()
    for k, v in m.items():
        for fn in v[1]:
            if fn in rev_m:
                rev_m[fn].append({k: v[0][0] if v[0] else ""})  # the mbc might be empty
            else:
                rev_m[fn] = [{k: v[0][0] if v[0] else ""}]
    return rev_m


def get_fn2capa(cap_json: dict) -> Dict[str, List[Dict[str, dict]]]:
    """
    Wrapper to call reverse_map on get_function_capabilities
    """
    return reverse_map(get_function_capabilities(cap_json))


def get_mbc_list(cap_json: dict) -> Set[str]:
    """
    Returns a dictionary containing the list of MBCs and ATT&CK ids
    """
    mbcs = set()
    attacks = set()
    for key, capability_data in cap_json['rules'].items():
        mbc = capability_data["meta"]["mbc"]
        attack = capability_data["meta"]["attack"]
        if mbc:
            mbcs.add(mbc[0]["id"])
        if attack:
            attacks.add(attack[0]["id"])
        # print("\nitem: ", key)
        # print("\tMBC: ", mbc)
        # print("\tATT&CK: ", attack)

    # print("MBCs: ", mbcs)
    # print("ATT&CKs: ", attacks)
    return {"MBCS": list(mbcs), "ATTACKS": list(attacks)}


def main():
    argparser = ap.ArgumentParser(description='''Capability Extractor''')
    argparser.add_argument('BIN', help='Binary file path')
    args = argparser.parse_args()
    binPath = Path(args.BIN)

    cap_json = CapabilityExtractor().getCapJson(binPath)  # dict
    capa2fn = get_function_capabilities(cap_json)
    fn2capa = reverse_map(capa2fn)
    mbc_list = get_mbc_list(cap_json)

    for k, v in capa2fn.items():
        print(k, v)

    for k, v in fn2capa.items():
        print(k, v)

    for k, v in mbc_list.items():
        print(k, v)


if __name__ == '__main__':
    main()
